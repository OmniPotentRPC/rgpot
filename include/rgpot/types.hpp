#pragma once
// MIT License
// Copyright 2023--present rgpot developers

/**
 * @file types.hpp
 * @author rgpot Developers
 * @date 2026-02-15
 * @brief C++ wrapper classes around the C API data exchange types.
 *
 * Provides two thin wrappers for the C structs generated by cbindgen:
 *
 * - @c InputSpec : manages DLPack tensor creation from raw CPU arrays.
 *   Move-only; frees the non-owning tensor metadata on destruction.
 * - @c CalcResult : receives the force tensor (DLPack) set by the callback
 *   and provides accessors for energy, variance, and CPU force data.
 *   Move-only; frees the owning forces tensor on destruction.
 *
 * These names are deliberately different from the legacy @c rgpot::ForceInput
 * and @c rgpot::ForceOut defined in @c ForceStructs.hpp to avoid name
 * collisions when both APIs are used in the same translation unit (e.g.,
 * inside the trampoline template in @c potential.hpp).
 *
 * @ingroup rgpot_cpp
 */

#include <cstddef>
#include <cstring>
#include <vector>

#include "rgpot.h"

namespace rgpot {

/**
 * @class InputSpec
 * @brief Move-only wrapper that creates non-owning DLPack tensors from raw
 *        CPU arrays.
 * @ingroup rgpot_cpp
 *
 * Wraps @c rgpot_force_input_t.  The constructor calls
 * @c rgpot_force_input_create() which creates non-owning DLPack tensors
 * wrapping the caller's buffers.  The destructor calls
 * @c rgpot_force_input_free() to release the tensor metadata (NOT the
 * underlying data).
 *
 * # Example
 * @code
 * double pos[] = {0,0,0, 1,0,0};
 * int    atm[] = {1, 1};
 * double box[] = {10,0,0, 0,10,0, 0,0,10};
 * rgpot::InputSpec input(2, pos, atm, box);
 * @endcode
 */
class InputSpec {
public:
  /**
   * @brief Construct from raw arrays (data is borrowed, not copied).
   * @param n_atoms Number of atoms in the configuration.
   * @param pos     Flat position array @c [n_atoms*3], row-major xyz.
   * @param atmnrs  Atomic number array @c [n_atoms].
   * @param box     Flat 3x3 cell matrix @c [9], row-major.
   */
  InputSpec(size_t n_atoms, double *pos, int *atmnrs, double *box)
      : n_atoms_(n_atoms),
        input_(rgpot_force_input_create(n_atoms, pos, atmnrs, box)) {}

  /**
   * @brief Construct from STL containers and a flat box pointer.
   * @param positions Flat position vector; size must be a multiple of 3.
   * @param atmnrs    Atomic number vector.
   * @param box       Flat 3x3 cell matrix @c [9], row-major.
   *
   * @note The vectors must outlive this InputSpec since the tensors borrow
   *       their data.
   */
  InputSpec(std::vector<double> &positions, std::vector<int> &atmnrs,
            double *box)
      : n_atoms_(positions.size() / 3),
        input_(rgpot_force_input_create(positions.size() / 3, positions.data(),
                                        atmnrs.data(), box)) {}

  ~InputSpec() { rgpot_force_input_free(&input_); }

  // Move-only
  InputSpec(InputSpec &&other) noexcept
      : n_atoms_(other.n_atoms_), input_(other.input_) {
    other.input_.positions = nullptr;
    other.input_.atomic_numbers = nullptr;
    other.input_.box_matrix = nullptr;
  }
  InputSpec &operator=(InputSpec &&other) noexcept {
    if (this != &other) {
      rgpot_force_input_free(&input_);
      n_atoms_ = other.n_atoms_;
      input_ = other.input_;
      other.input_.positions = nullptr;
      other.input_.atomic_numbers = nullptr;
      other.input_.box_matrix = nullptr;
    }
    return *this;
  }
  InputSpec(const InputSpec &) = delete;
  InputSpec &operator=(const InputSpec &) = delete;

  /**
   * @brief Access the underlying C struct.
   * @return Const reference to the wrapped @c rgpot_force_input_t.
   */
  const rgpot_force_input_t &c_struct() const { return input_; }

  /**
   * @brief Returns the number of atoms.
   * @return Atom count.
   */
  size_t n_atoms() const { return n_atoms_; }

private:
  size_t n_atoms_;
  rgpot_force_input_t input_;
};

/**
 * @class CalcResult
 * @brief Owns the force DLPack tensor and stores energy/variance from a
 *        calculation.
 * @ingroup rgpot_cpp
 *
 * Wraps @c rgpot_force_out_t.  The @c forces field starts as @c NULL and is
 * set by the potential callback to an owning DLPack tensor.  The destructor
 * calls @c rgpot_tensor_free() to release the forces tensor.
 *
 * For CPU tensors, use @c forces_data() to access the raw pointer or
 * @c forces_vec() to copy forces into a @c std::vector<double>.
 */
class CalcResult {
public:
  /**
   * @brief Create a zeroed result buffer for a calculation.
   */
  CalcResult() : output_(rgpot_force_out_create()) {}

  ~CalcResult() {
    if (output_.forces) {
      rgpot_tensor_free(output_.forces);
    }
  }

  // Move-only
  CalcResult(CalcResult &&other) noexcept : output_(other.output_) {
    other.output_.forces = nullptr;
  }
  CalcResult &operator=(CalcResult &&other) noexcept {
    if (this != &other) {
      if (output_.forces) {
        rgpot_tensor_free(output_.forces);
      }
      output_ = other.output_;
      other.output_.forces = nullptr;
    }
    return *this;
  }
  CalcResult(const CalcResult &) = delete;
  CalcResult &operator=(const CalcResult &) = delete;

  /**
   * @brief Access the underlying C struct (mutable).
   * @return Mutable reference; used internally by @c
   * PotentialHandle::calculate().
   */
  rgpot_force_out_t &c_struct() { return output_; }

  /**
   * @brief Returns the calculated potential energy.
   * @return Energy in the unit system of the potential.
   */
  double energy() const { return output_.energy; }

  /**
   * @brief Returns the variance / uncertainty estimate.
   * @return Variance (0.0 when not applicable).
   */
  double variance() const { return output_.variance; }

  /**
   * @brief Returns a raw pointer to the forces data (CPU only).
   *
   * The returned pointer is valid for the lifetime of this CalcResult.
   *
   * @param n_elements Output: number of doubles in the forces array.
   * @return Raw pointer to the force data, or @c nullptr if no forces tensor.
   */
  const double *forces_data(size_t &n_elements) const {
    if (!output_.forces) {
      n_elements = 0;
      return nullptr;
    }
    auto *tensor = &output_.forces->dl_tensor;
    n_elements = 1;
    for (int i = 0; i < tensor->ndim; ++i) {
      n_elements *= static_cast<size_t>(tensor->shape[i]);
    }
    return static_cast<const double *>(tensor->data);
  }

  /**
   * @brief Copy forces into a std::vector<double>.
   * @return Vector of forces [n_atoms * 3].
   */
  std::vector<double> forces_vec() const {
    size_t n = 0;
    const double *data = forces_data(n);
    if (!data || n == 0) {
      return {};
    }
    return std::vector<double>(data, data + n);
  }

  /**
   * @brief Check if forces are available.
   * @return True if the forces tensor has been set by the callback.
   */
  bool has_forces() const { return output_.forces != nullptr; }

private:
  rgpot_force_out_t output_;
};

} // namespace rgpot
