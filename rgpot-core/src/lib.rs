// MIT License
// Copyright 2023--present rgpot developers

// C-style names are intentional for cbindgen compatibility.
#![allow(non_camel_case_types)]

//! # rgpot-core
//!
//! Rust core library for rgpot: RPC-based distributed potential energy surface
//! calculations. This crate follows the
//! [metatensor](https://docs.metatensor.org/) architecture pattern: a Rust core
//! that defines fundamental types, exposed via a stable C ABI (auto-generated by
//! [cbindgen](https://github.com/mozilla/cbindgen)), with hand-written C++ RAII
//! wrappers on top.
//!
//! ## Module Overview
//!
//! | Module | Purpose |
//! |--------|---------|
//! | [`types`] | `#[repr(C)]` data structures for force/energy I/O |
//! | [`status`] | Status codes, thread-local error message, panic safety |
//! | [`potential`] | Callback-based potential dispatch (opaque handle) |
//! | [`c_api`] | `extern "C"` entry points collected by cbindgen |
//! | [`rpc`] | Cap'n Proto RPC client and server (feature-gated) |
//!
//! ## Design Principles
//!
//! 1. **C ABI is the contract.** Every public type is `#[repr(C)]` and every
//!    public function is `extern "C"`. The generated `rgpot.h` header is the
//!    single source of truth for all language bindings.
//!
//! 2. **Panic safety at every boundary.** All `extern "C"` functions wrap their
//!    body in [`status::catch_unwind`], converting panics to
//!    [`status::rgpot_status_t::RGPOT_INTERNAL_ERROR`] and storing a
//!    human-readable message retrievable via [`status::rgpot_last_error`].
//!
//! 3. **Callback-based dispatch.** C++ potentials register themselves as
//!    function pointer callbacks. The Rust core never depends on concrete C++
//!    types â€” only on the callback signature.
//!
//! 4. **Feature-gated optional layers.** RPC (`rpc` feature) and caching
//!    (`cache` feature) are opt-in, keeping the core dependency-free.
//!
//! ## Quick Example (Rust-side)
//!
//! ```rust
//! use rgpot_core::types::*;
//! use rgpot_core::status::rgpot_status_t;
//! use rgpot_core::potential::PotentialImpl;
//!
//! // Define a trivial callback
//! unsafe extern "C" fn my_callback(
//!     _ud: *mut std::os::raw::c_void,
//!     input: *const rgpot_force_input_t,
//!     output: *mut rgpot_force_out_t,
//! ) -> rgpot_status_t {
//!     let inp = unsafe { &*input };
//!     let out = unsafe { &mut *output };
//!     out.energy = inp.n_atoms as f64 * 42.0;
//!     rgpot_status_t::RGPOT_SUCCESS
//! }
//!
//! let pot = PotentialImpl::new(my_callback, std::ptr::null_mut(), None);
//! // pot.calculate(&input, &mut output) dispatches to my_callback
//! ```

pub mod types;
pub mod status;
pub mod potential;
pub mod c_api;

#[cfg(feature = "rpc")]
pub mod rpc;
