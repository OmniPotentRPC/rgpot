// MIT License
// Copyright 2023--present rgpot developers
//
// Auto-generated by cbindgen — do not edit manually.


#ifndef RGPOT_H
#define RGPOT_H

/* Generated with cbindgen:0.27.0 */

/* Warning: this file is auto-generated by cbindgen. Do not modify this manually. */

#include <stdarg.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>

/**
 * Status codes returned by all C API functions.
 */
typedef enum rgpot_status_t {
  /**
   * Operation completed successfully.
   */
  RGPOT_SUCCESS = 0,
  /**
   * An invalid parameter was passed (null pointer, wrong size, etc.).
   */
  RGPOT_INVALID_PARAMETER = 1,
  /**
   * An internal error occurred (e.g. a Rust panic was caught).
   */
  RGPOT_INTERNAL_ERROR = 2,
  /**
   * An RPC communication error occurred.
   */
  RGPOT_RPC_ERROR = 3,
  /**
   * A buffer was too small for the requested operation.
   */
  RGPOT_BUFFER_SIZE_ERROR = 4,
} rgpot_status_t;

/**
 * Opaque potential handle wrapping a callback + user data.
 */
typedef struct PotentialImpl PotentialImpl;

#if defined(RGPOT_HAS_RPC)
/**
 * RPC client that connects to a remote rgpot server.
 */
typedef struct RpcClient RpcClient;
#endif

/**
 * Input configuration for a potential energy evaluation.
 *
 * All pointer fields are *borrowed* — the caller retains ownership and must
 * keep the underlying arrays alive for the lifetime of this struct.
 *
 * # Fields
 *
 * - `pos`: flat array of atomic coordinates, `[n_atoms * 3]` doubles in
 *   row-major order (x0, y0, z0, x1, y1, z1, ...).
 * - `atmnrs`: atomic numbers, `[n_atoms]` ints.
 * - `box_`: simulation cell vectors as a flat 3x3 row-major matrix, `[9]`
 *   doubles.
 *
 * # Example (from C)
 *
 * ```c
 * double positions[] = {0.0, 0.0, 0.0,  1.0, 0.0, 0.0};
 * int    types[]     = {1, 1};
 * double cell[]      = {10.0,0,0, 0,10.0,0, 0,0,10.0};
 *
 * rgpot_force_input_t input = rgpot_force_input_create(2, positions, types, cell);
 * ```
 */
typedef struct rgpot_force_input_t {
  /**
   * Total number of atoms in the configuration.
   */
  uintptr_t n_atoms;
  /**
   * Pointer to flat position array `[n_atoms * 3]`.
   */
  const double *pos;
  /**
   * Pointer to atomic number array `[n_atoms]`.
   */
  const int *atmnrs;
  /**
   * Pointer to the 3x3 cell matrix `[9]`, row-major.
   */
  const double *box_;
} rgpot_force_input_t;

/**
 * Results from a potential energy evaluation.
 *
 * The `forces` pointer must be pre-allocated by the caller with at least
 * `n_atoms * 3` doubles. The `energy` and `variance` fields are written by the
 * potential callback.
 *
 * # Fields
 *
 * - `forces`: output force array, same layout as `pos` in
 *   [`rgpot_force_input_t`].
 * - `energy`: the calculated potential energy (eV or consistent unit).
 * - `variance`: uncertainty estimate; zero when not applicable.
 */
typedef struct rgpot_force_out_t {
  /**
   * Pointer to force output buffer `[n_atoms * 3]`.
   */
  double *forces;
  /**
   * Calculated potential energy.
   */
  double energy;
  /**
   * Variance / uncertainty of the calculation (0.0 when unused).
   */
  double variance;
} rgpot_force_out_t;

/**
 * Opaque handle exposed to C as `rgpot_potential_t`.
 *
 * This is a type alias used by cbindgen to generate a forward declaration.
 */
typedef struct PotentialImpl rgpot_potential_t;

/**
 * Function pointer type for a potential energy calculation.
 *
 * The callback receives:
 * - `user_data`: opaque pointer to the C++ object (e.g. `LJPot*`)
 * - `input`: the atomic configuration
 * - `output`: the buffer for results
 *
 * Returns `RGPOT_SUCCESS` on success, or an error status code.
 */
typedef enum rgpot_status_t (*PotentialCallback)(void *user_data,
                                                 const struct rgpot_force_input_t *input,
                                                 struct rgpot_force_out_t *output);

#if (defined(RGPOT_HAS_RPC) && defined(RGPOT_HAS_RPC))
/**
 * Opaque RPC client handle.
 */
typedef struct RpcClient rgpot_rpc_client_t;
#endif

/**
 * Retrieve a pointer to the last error message for the current thread.
 *
 * The pointer is valid until the next call to any `rgpot_*` function
 * on the same thread.
 *
 * # Safety
 * This is intended to be called from C. The returned pointer must not
 * be freed by the caller.
 */
const char *rgpot_last_error(void);

/**
 * Create a `rgpot_force_input_t` from raw pointers.
 *
 * This is a convenience constructor for C callers. All pointers
 * are borrowed — the caller retains ownership.
 *
 * # Safety
 * All pointers must be valid for the lifetime of the returned struct.
 * `pos` must point to at least `n_atoms * 3` doubles.
 * `atmnrs` must point to at least `n_atoms` ints.
 * `box_` must point to at least 9 doubles.
 */
struct rgpot_force_input_t rgpot_force_input_create(uintptr_t n_atoms,
                                                    const double *pos,
                                                    const int *atmnrs,
                                                    const double *box_);

/**
 * Create a `rgpot_force_out_t` with zeroed energy and variance.
 *
 * # Safety
 * `forces` must point to a buffer of at least `n_atoms * 3` doubles.
 */
struct rgpot_force_out_t rgpot_force_out_create(double *forces);

/**
 * Create a new potential handle from a callback function pointer.
 *
 * - `callback`: the function that performs the force/energy calculation.
 * - `user_data`: opaque pointer forwarded to every callback invocation
 *   (typically a pointer to the C++ potential object).
 * - `free_fn`: optional destructor for `user_data`. Pass `NULL` if the
 *   caller manages the lifetime externally.
 *
 * Returns a heap-allocated `rgpot_potential_t*`, or `NULL` on failure.
 * The caller must eventually pass the returned pointer to
 * `rgpot_potential_free`.
 */
rgpot_potential_t *rgpot_potential_new(PotentialCallback callback,
                                       void *user_data,
                                       void (*free_fn)(void*));

/**
 * Perform a force/energy calculation using the potential handle.
 *
 * - `pot`: a valid handle obtained from `rgpot_potential_new`.
 * - `input`: pointer to the input configuration.
 * - `output`: pointer to the output buffer (forces must be pre-allocated).
 *
 * Returns `RGPOT_SUCCESS` on success, or an error status code.
 * On error, call `rgpot_last_error()` for details.
 */
enum rgpot_status_t rgpot_potential_calculate(const rgpot_potential_t *pot,
                                              const struct rgpot_force_input_t *input,
                                              struct rgpot_force_out_t *output);

/**
 * Free a potential handle previously obtained from `rgpot_potential_new`.
 *
 * If `pot` is `NULL`, this function is a no-op.
 * After this call, `pot` must not be used again.
 */
void rgpot_potential_free(rgpot_potential_t *pot);

#if (defined(RGPOT_HAS_RPC) && defined(RGPOT_HAS_RPC))
/**
 * Create a new RPC client connected to `host:port`.
 *
 * Returns a heap-allocated handle, or `NULL` on failure.
 * The caller must eventually call `rgpot_rpc_client_free`.
 */
rgpot_rpc_client_t *rgpot_rpc_client_new(const char *host, uint16_t port);
#endif

#if (defined(RGPOT_HAS_RPC) && defined(RGPOT_HAS_RPC))
/**
 * Perform a remote force/energy calculation.
 *
 * Returns `RGPOT_SUCCESS` on success, or an error status code.
 */
enum rgpot_status_t rgpot_rpc_calculate(rgpot_rpc_client_t *client,
                                        const struct rgpot_force_input_t *input,
                                        struct rgpot_force_out_t *output);
#endif

#if (defined(RGPOT_HAS_RPC) && defined(RGPOT_HAS_RPC))
/**
 * Free an RPC client handle.
 *
 * If `client` is `NULL`, this is a no-op.
 */
void rgpot_rpc_client_free(rgpot_rpc_client_t *client);
#endif

#if defined(RGPOT_HAS_RPC)
/**
 * Start an RPC server listening on `host:port`, dispatching to `pot`.
 *
 * This function blocks the current thread. It creates its own tokio runtime.
 *
 * # Safety
 * `pot` must be a valid pointer obtained from `rgpot_potential_new`.
 * The potential and its user_data must remain valid for the lifetime
 * of the server.
 */
enum rgpot_status_t rgpot_rpc_server_start(const rgpot_potential_t *pot,
                                           const char *host,
                                           uint16_t port);
#endif

#endif  /* RGPOT_H */


